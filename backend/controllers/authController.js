const User = require('../models/User');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const sendEmail = require('../utils/sendEmail');

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ Gmail
const isValidGmail = (email) => /^[a-zA-Z0-9._%+-]+@gmail\.com$/.test(email);

// üîπ 1. –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
exports.sendVerificationCode = async (req, res) => {
  try {
    const { email } = req.body;
    if (!isValidGmail(email)) {
      return res.status(400).json({ message: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Gmail-–∞–¥—Ä–µ—Å' });
    }

    const normalizedEmail = email.toLowerCase();
    const existing = await User.findOne({ email: normalizedEmail });

    if (existing && existing.password) {
      return res.status(400).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω' });
    }

    const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
    const expires = new Date(Date.now() + 5 * 60 * 1000); // 5 –º–∏–Ω—É—Ç

    await sendEmail(normalizedEmail, verificationCode);

    // –°–æ–∑–¥–∞—ë–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = existing || new User({ email: normalizedEmail });
    user.verificationCode = verificationCode;
    user.verificationCodeExpires = expires;
    user.isEmailVerified = false;

    await user.save();
    res.status(200).json({ message: '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ Gmail' });

  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–¥–∞:', err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};

// üîπ 2. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∫–æ–¥–∞
exports.verifyCode = async (req, res) => {
  try {
    const { email, code } = req.body;
    const user = await User.findOne({ email: email.toLowerCase() });

    if (!user || user.verificationCode !== code) {
      return res.status(400).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥' });
    }

    if (Date.now() > user.verificationCodeExpires) {
      return res.status(400).json({ message: '–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞ –∏—Å—Ç—ë–∫' });
    }

    user.isEmailVerified = true;
    user.verificationCode = null;
    user.verificationCodeExpires = null;
    await user.save();

    res.status(200).json({ message: 'Email —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω' });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏:', err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};

// üîπ 3. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞—Ä–æ–ª—è
exports.setPassword = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email: email.toLowerCase() });

    if (!user || !user.isEmailVerified) {
      return res.status(400).json({ message: 'Email –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω' });
    }

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º (–∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º) –ø–∞—Ä–æ–ª—å
    user.password = await bcrypt.hash(password, 10);

    // ‚ùó –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä–æ–ª—è ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, —á—Ç–æ–±—ã –∑–ª–æ—É–º—ã—à–ª–µ–Ω–Ω–∏–∫ –Ω–µ —Å–º–æ–≥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ
    user.isEmailVerified = false;

    await user.save();
    res.status(200).json({ message: '–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω' });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä–æ–ª—è:', err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};


// üîπ 4. –í—Ö–æ–¥
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email: email.toLowerCase() });

    if (!user || !user.password) {
      return res.status(404).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é' });
    }

    const match = await bcrypt.compare(password, user.password);
    if (!match) {
      return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å' });
    }

    const token = jwt.sign({
      userId: user._id,
      role: user.role,
      isDriver: user.isDriver,
      isVerified: user.isVerified
    }, process.env.JWT_SECRET, { expiresIn: '7d' });

    res.status(200).json({
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        isDriver: user.isDriver,
        isVerified: user.isVerified
      }
    });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};

// üîê –í—Ö–æ–¥ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
exports.adminLogin = async (req, res) => {
  try {
    const { email, password } = req.body;

    const admin = await User.findOne({ email: email.toLowerCase(), role: 'admin' });
    if (!admin || !admin.password) {
      return res.status(404).json({ message: '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    const isMatch = await bcrypt.compare(password, admin.password);
    if (!isMatch) {
      return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å' });
    }

    const token = jwt.sign(
      { userId: admin._id, role: 'admin' },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.status(200).json({
      token,
      user: {
        id: admin._id,
        email: admin.email,
        role: admin.role
      }
    });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:', err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};
